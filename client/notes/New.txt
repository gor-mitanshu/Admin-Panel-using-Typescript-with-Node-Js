/*FRONTEND*/
index.tsx
import React from "react";
import ReactDOM from "react-dom/client";
import "./App.css";
import App from "./App";
import { Provider } from "react-redux";
import { store, persistor } from "redux/Store";
import { PersistGate } from "redux-persist/integration/react";
import { Auth0Provider } from "@auth0/auth0-react";
import { BrowserRouter as Router } from "react-router-dom";

const domainId = "dev-1x51ocfjf18nwb0k.us.auth0.com";
const clientId = "hlEvO2FIh0eJ9cnB3PpBZOw5CrjUf9Ml";

const root = ReactDOM.createRoot(
  document.getElementById("root") as HTMLElement
);
root.render(
  <Router>
    <Auth0Provider
      domain={domainId}
      clientId={clientId}
      authorizationParams={{
        redirect_uri: window.location.origin,
      }}
    >
      <Provider store={store}>
        <PersistGate loading={null} persistor={persistor}>
          <App />
        </PersistGate>
      </Provider>
    </Auth0Provider>
  </Router>
);





App.tsx
import React from "react";
import { Navigate, Route, Routes } from "react-router-dom";
import LoginPage from "pages/Login/LoginPage";
import Layout from "components/Layout/Layout";
import Dashboard from "pages/Dashboard/DashboardPage";
import ProfilePage from "pages/Profile/ProfilePage/ProfilePage";
import ProfileUpdatePage from "pages/Profile/ProfileUpdatePage/ProfileUpdatePage";
import { AuthProvider } from "context/authContext";

function App() {
  return (
    <AuthProvider>
      <Routes>
        <Route path="/login" element={<LoginPage />} />
        <Route path="/" element={<Layout />}>
          <Route index element={<Navigate to="/dashboard" replace />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/profile" element={<ProfilePage />} />
          <Route
            path="/profile/updateprofile/:id"
            element={<ProfileUpdatePage />}
          />
        </Route>
      </Routes>
    </AuthProvider>
  );
}

export default App;





utils/api.ts
import axios from "axios";

const api = axios.create({
  baseURL: process.env.REACT_APP_API,
});

api.interceptors.response.use(
  (response) => response,
  (error) => {
    return Promise.reject(error);
  }
);

export default api;





redux/types/authTypes.ts
export const enum AuthActionTypes {
  LOGIN_SUCCESS = "LOGIN_SUCCESS",
  LOGIN_FAILURE = "LOGIN_FAILURE",
  LOGOUT = "LOGOUT",
  GET_USER_SUCCESS = "GET_USER_SUCCESS",
  GET_USER_FAILURE = "GET_USER_FAILURE",
  UPDATE_USER_SUCCESS = "UPDATE_USER_SUCCESS",
  UPDATE_USER_FAILURE = "UPDATE_USER_FAILURE",
}
export interface User {
  _id?: string;
  firstname: string;
  lastname: string;
  phone: string;
  email: string;
  role?: string;
  createdAt?: any;
  updatedAt?: any;
}
export interface AuthState {
  token: string | null;
  error: string | null;
}
export interface UserState {
  user: User | null;
  error: string | null;
}





redux/reducer.ts
import { AuthActionTypes, AuthState, UserState } from "./types/authTypes";

const initialLoginState: AuthState = {
  token: null,
  error: null,
};
export const LoginAuthReducer = (
  state = initialLoginState,
  action: any
): AuthState => {
  switch (action.type) {
    case AuthActionTypes.LOGIN_SUCCESS:
      return {
        ...state,
        token: action.payload,
        error: null,
      };
    case AuthActionTypes.LOGIN_FAILURE:
      return {
        ...state,
        token: null,
        error: action.payload,
      };
    case AuthActionTypes.LOGOUT:
      return {
        ...state,
        token: null,
        error: null,
      };
    default:
      return state;
  }
};

const initialUserState: UserState = {
  user: null,
  error: null,
};

export const UserReducer = (
  state = initialUserState,
  action: any
): UserState => {
  switch (action.type) {
    case AuthActionTypes.GET_USER_SUCCESS:
      return {
        ...state,
        user: action.payload,
        error: null,
      };
    case AuthActionTypes.GET_USER_FAILURE:
      return {
        ...state,
        user: null,
        error: action.payload,
      };
    case AuthActionTypes.UPDATE_USER_SUCCESS:
      return {
        ...state,
        user: action.payload,
        error: null,
      };
    case AuthActionTypes.UPDATE_USER_FAILURE:
      return {
        ...state,
        error: action.payload,
      };
    default:
      return state;
  }
};





redux/combineReducers.ts
import { combineReducers } from "redux";
import { AuthState, UserState } from "./types/authTypes";
import { LoginAuthReducer, UserReducer } from "../redux/Reducer";

export interface RootState {
  LoginAuthReducer: AuthState;
  UserReducer: UserState;
}

const rootReducer = combineReducers({
  LoginAuthReducer,
  UserReducer,
});

export default rootReducer;





redux/action.ts
import axios from "axios"; //  { isAxiosError }
import { Dispatch } from "redux";
import {
  AuthActionTypes,
  //  User
} from "./types/authTypes";
// import api from "utils/api";

interface LoginRequestPayload {
  email: string;
  password: string;
}

export const login =
  (payload: LoginRequestPayload) => async (dispatch: Dispatch) => {
    try {
      const response = await axios.post(
        `${process.env.REACT_APP_API}/api/login`,
        payload
      );
      const { token } = response.data.result;
      dispatch({ type: AuthActionTypes.LOGIN_SUCCESS, payload: token });
      return response;
    } catch (error: any) {
      // console.log(error);
      dispatch({
        type: AuthActionTypes.LOGIN_FAILURE,
        payload: error.response.data.message,
      });
      throw error;
    }
  };

// export const getUser = () => async (dispatch: Dispatch, getState: any) => {
//   try {
//     const token = getState().LoginAuthReducer.token;
//     if (!token) {
//       throw new Error("Token not found");
//     }
//     const response = await api.get(`${process.env.REACT_APP_API}/api/getuser`, {
//       headers: {
//         Authorization: `Bearer ${token}`,
//       },
//     });
//     console.log(response);
//     if (
//       !!response &&
//       !!response.data.success === true &&
//       response.status === 200
//     ) {
//       dispatch({
//         type: AuthActionTypes.GET_USER_SUCCESS,
//         payload: response.data.user,
//       });
//     } else {
//       dispatch({
//         type: AuthActionTypes.GET_USER_FAILURE,
//         payload: "Error fetching user data.",
//       });
//     }
//   } catch (error) {
//     if (isAxiosError(error)) {
//       if (error.response?.status === 401) {
//         dispatch({ type: AuthActionTypes.LOGOUT });
//         console.log(error, "Mitanshu Unauthorized");
//       } else {
//         console.log("Axios Other error" + error.message);
//       }
//     }
//     console.log(error);
//   }
// };

// export const updateUser =
//   (updatedUserData: User) => async (dispatch: Dispatch, getState: any) => {
//     try {
//       const token = getState().LoginAuthReducer.token;
//       if (!token) {
//         throw new Error("Token not found");
//       }
//       await api.put(
//         `${process.env.REACT_APP_API}/api/updateuser/${updatedUserData._id}`,
//         updatedUserData,
//         {
//           headers: {
//             Authorization: `Bearer ${token}`,
//           },
//         }
//       );
//       dispatch({
//         type: AuthActionTypes.UPDATE_USER_SUCCESS,
//         payload: updatedUserData,
//       });
//     } catch (error) {
//       console.log(error);
//       if (isAxiosError(error)) {
//         console.log(error);
//         dispatch({
//           type: AuthActionTypes.UPDATE_USER_FAILURE,
//           payload: "Error updating user data.",
//         });
//       }
//     }
//   };

export const logout = () => (dispatch: Dispatch) => {
  dispatch({ type: AuthActionTypes.LOGOUT });
};





redux/store.ts
import { configureStore } from "@reduxjs/toolkit";
import thunk from "redux-thunk";
import { persistStore, persistReducer } from "redux-persist";
import storage from "redux-persist/lib/storage";
import rootReducer from "./combineReducer";

const persistConfig = {
  key: "auth",
  storage,
  whitelist: ["LoginAuthReducer"],
};

const persistedReducer = persistReducer(persistConfig, rootReducer);
const store = configureStore({
  reducer: persistedReducer,
  middleware: [thunk],
});
const persistor = persistStore(store);

export { store, persistor };





ProtectedRoute/ProtectedRoute.tsx
import React from "react";

const ProtectedRoute = () => {
  return <div>ProtectedRoute</div>;
};

export default ProtectedRoute;





pages/Login/LoginPage.tsx
import React from "react";
import { useAuth0 } from "@auth0/auth0-react";
import { Button } from "@mui/material";

const Login: React.FC = () => {
  const { loginWithRedirect } = useAuth0();

  //   useEffect(() => {
  //   loginWithRedirect();
  // }, []);
  return (
    <div>
      <h1>Login Page</h1>
      <Button variant="contained" onClick={() => loginWithRedirect()}>
        Log In
      </Button>
    </div>
  );
};

export default Login;





pages/Dashboard/DashboardPage.tsx
import React from "react";
import "../Dashboard/DashboardPage.css";
import { Box, Card, CardContent, Grid, Typography } from "@mui/material";
import { CurretWeekChart, LastWeekChart, PieChart } from "./Chart/Chart";

const Dashboard = (): JSX.Element => {
  return (
    <>
      <Grid container padding={2} spacing={1}>
        <Grid item lg={3} md={6} sm={12} xs={12}>
          <Card className="card card-1">
            <Box className="card-box" />
            <Box sx={{ display: "flex", flexDirection: "column" }}>
              <CardContent>
                <Typography
                  component="div"
                  variant="h5"
                  sx={{ fontSize: "2rem", position: "relative", zIndex: 1 }}
                >
                  Card 1
                </Typography>
                <Typography
                  variant="subtitle1"
                  color="#fff"
                  component="div"
                  sx={{ position: "relative", zIndex: 1 }}
                >
                  Lorem ipsum dolor sit
                </Typography>
              </CardContent>
            </Box>
          </Card>
        </Grid>
        <Grid item lg={3} md={6} sm={12} xs={12}>
          <Card className="card card-2">
            <Box className="card-box" />
            <Box sx={{ display: "flex", flexDirection: "column" }}>
              <CardContent>
                <Typography
                  component="div"
                  variant="h5"
                  sx={{ fontSize: "2rem", position: "relative", zIndex: 1 }}
                >
                  Card 2
                </Typography>
                <Typography
                  variant="subtitle1"
                  color="#fff"
                  component="div"
                  sx={{ position: "relative", zIndex: 1 }}
                >
                  Lorem ipsum dolor sit
                </Typography>
              </CardContent>
            </Box>
          </Card>
        </Grid>
        <Grid item lg={3} md={6} sm={12} xs={12}>
          <Card className="card card-3">
            <Box className="card-box" />
            <Box sx={{ display: "flex", flexDirection: "column" }}>
              <CardContent>
                <Typography
                  component="div"
                  variant="h5"
                  sx={{ fontSize: "2rem", position: "relative", zIndex: 1 }}
                >
                  Card 3
                </Typography>
                <Typography
                  variant="subtitle1"
                  color="#fff"
                  component="div"
                  sx={{ position: "relative", zIndex: 1 }}
                >
                  Lorem ipsum dolor sit
                </Typography>
              </CardContent>
            </Box>
          </Card>
        </Grid>
        <Grid item lg={3} md={6} sm={12} xs={12}>
          <Card className="card card-4">
            <Box className="card-box" />
            <Box sx={{ display: "flex", flexDirection: "column" }}>
              <CardContent>
                <Typography
                  component="div"
                  variant="h5"
                  sx={{ fontSize: "2rem", position: "relative", zIndex: 1 }}
                >
                  Card 4
                </Typography>
                <Typography
                  variant="subtitle1"
                  color="#fff"
                  component="div"
                  sx={{ position: "relative", zIndex: 1 }}
                >
                  Lorem ipsum dolor sit
                </Typography>
              </CardContent>
            </Box>
          </Card>
        </Grid>

        <Grid item lg={6} xs={12}>
          <CurretWeekChart />
        </Grid>
        <Grid item lg={6} xs={12}>
          <LastWeekChart />
        </Grid>
        <Grid item lg={6} xs={12}>
          <PieChart />
        </Grid>
      </Grid>
    </>
  );
};

export default Dashboard;





pages/Dashboard/Chart/Chart.tsx
import { Card } from "@mui/material";
import React, { useState, useEffect } from "react";
import ReactEcharts from "echarts-for-react";
import * as echarts from "echarts"; // Import the echarts library
import axios from "axios";

export const CurretWeekChart = () => {
  const [currentWeekDates, setCurrentWeekDates] = useState<string[]>([]);

  useEffect(() => {
    const currentweekDates = getCurrentWeekDates();
    setCurrentWeekDates(currentweekDates);
  }, []);

  // function to get the week data
  const getCurrentWeekDates = (): string[] => {
    const currentDate = new Date();
    const currentDayOfWeek = currentDate.getDay(); // Sunday = 0, Monday = 1, ..., Saturday = 6
    const firstDayOfWeek = new Date(currentDate);
    firstDayOfWeek.setDate(currentDate.getDate() - currentDayOfWeek);

    const weekDates: string[] = [];
    for (let i = 0; i < 7; i++) {
      const date = new Date(firstDayOfWeek);
      date.setDate(firstDayOfWeek.getDate() + i);
      const formattedDate = date.toISOString().slice(0, 10);
      weekDates.push(formattedDate);
    }
    return weekDates;
  };

  const option = {
    title: {
      text: "Current Week's Weekly Data",
      subtext: "Aug 2023",
      center: "",
    },
    xAxis: {
      type: "category",
      data: currentWeekDates,
      stack: "x",
    },
    yAxis: {
      type: "value",
    },
    series: [
      {
        name: "Data",
        bottom: "left",
        data: [10, 20, 30, 40, 50, 60, 80],
        type: "bar",
        stack: "x",
        showBackground: true,
        backgroundStyle: {
          color: "rgba(180, 180, 180, 0.2)",
        },
      },
    ],
    tooltip: {
      trigger: "axis",
    },
    legend: {
      data: ["Data"],
    },
    grid: {
      containLabel: true,
    },
    responsive: true,
    maintainAspectRatio: false,
    //     color: ["#ff7070"],
  };

  return (
    <div>
      <Card
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          marginTop: "20px",
        }}
      >
        <ReactEcharts
          option={option}
          style={{ height: "65vh", width: "100%" }}
        />
      </Card>
    </div>
  );
};

export const LastWeekChart = () => {
  const [lastWeekDates, setLastWeekDates] = useState<string[]>([]);

  useEffect(() => {
    const lastweekDates = getlastWeekDates();
    setLastWeekDates(lastweekDates);
  }, []);

  // Function to get last week data
  const getlastWeekDates = (): string[] => {
    const currentDate = new Date();
    const currentDayOfWeek = currentDate.getDay(); // Sunday = 0, Monday = 1, ..., Saturday = 6
    const firstDayOfLastWeek = new Date(currentDate);
    firstDayOfLastWeek.setDate(currentDate.getDate() - currentDayOfWeek - 7); // Subtracting 7 days for the last week

    const lastWeekDates: string[] = [];
    for (let i = 0; i < 7; i++) {
      const date = new Date(firstDayOfLastWeek);
      date.setDate(firstDayOfLastWeek.getDate() + i);
      const formattedDate = date.toISOString().slice(0, 10);
      lastWeekDates.push(formattedDate);
    }
    return lastWeekDates;
  };

  const option = {
    title: {
      text: "Last Week's Weekly Data",
      subtext: "Aug 2023",
      center: "",
    },
    xAxis: {
      type: "category",
      data: lastWeekDates,
      stack: "x",
    },
    yAxis: {
      type: "value",
    },
    series: [
      {
        name: "Data",
        bottom: "left",
        data: [80, 70, 60, 50, 50, 60, 80],
        type: "bar",
        stack: "x",
        showBackground: true,
        backgroundStyle: {
          color: "rgba(180, 180, 180, 0.2)",
        },
        emphasis: {
          // Use `label` to display the highest value on the bar
          label: {
            show: true,
            position: "top",
          },
        },
        itemStyle: {
          // Use `color` to highlight the highest value bar with a different color
          color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
            { offset: 0, color: "#2378f7" }, // Start color
            { offset: 1, color: "#83bff6" }, // End color
          ]),
        },
      },
    ],
    tooltip: {
      trigger: "axis",
    },
    legend: {
      data: ["Data"],
    },
    grid: {
      containLabel: true,
    },
    responsive: true,
    maintainAspectRatio: false,
    //     color: ["#ff7070"],
  };

  return (
    <div>
      <Card
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          marginTop: "20px",
        }}
      >
        <ReactEcharts
          option={option}
          style={{ height: "65vh", width: "100%" }}
        />
      </Card>
    </div>
  );
};

export const PieChart = () => {
  const [studentChartData, setStudentChartData] = useState<any>([]);

  const categories = [
    "first_class",
    "second_class",
    "third_class",
    "fail",
    "distinction",
  ];
  const PieChartStudentData = async () => {
    try {
      const response = await axios.get(`${process.env.REACT_APP_API_JSON}`);
      const students = response.data;
      const totalResultCounts: any = {};

      categories.forEach((category) => {
        totalResultCounts[category] = 0;
      });

      students.forEach((student: any) => {
        if (categories.includes(student.result)) {
          totalResultCounts[student.result]++;
        }
      });

      setStudentChartData(totalResultCounts);
      console.log(response.data);
    } catch (error) {
      console.error("Error fetching data:", error);
    }
  };
  useEffect(() => {
    PieChartStudentData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const option = {
    title: {
      text: "Students Record",
      subtext: "Students",
      bottom: "bottom",
    },
    series: [
      {
        data: categories.map((category: any) => ({
          value: studentChartData[category],
          name: category.replace("_", " ").toUpperCase(),
        })),
        type: "pie",
        roseType: "area",
        // name: "Student Data",
        bottom: "left",
        stack: "x",
        showBackground: true,
        backgroundStyle: {
          color: "rgba(180, 180, 180, 0.2)",
        },
      },
    ],
    tooltip: {
      trigger: "item",
    },
    legend: {
      data: categories.map((category) =>
        category.replace("_", " ").toUpperCase()
      ),
    },
    grid: {
      containLabel: true,
    },
    responsive: true,
    maintainAspectRatio: false,
  };

  return (
    <div>
      <Card
        sx={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
        }}
      >
        <ReactEcharts
          option={option}
          style={{ height: "65vh", width: "100%" }}
        />
      </Card>
    </div>
  );
};





pages/Profile/ProfilePage.tsx
import React from "react";
import { useAuth0 } from "@auth0/auth0-react";
import { Container, Typography, Button } from "@mui/material";
import Loader from "loader/Loader";

const Profile: React.FC = () => {
  const { user, isAuthenticated, isLoading } = useAuth0();
  console.log(user);

  if (isLoading) {
    return <Loader />;
  }

  return (
    <Container maxWidth="md">
      <Typography className="profile-title">Profile</Typography>
      {isAuthenticated ? (
        <div>
          <Typography variant="body1" gutterBottom>
            <span className="label">Name:</span>{" "}
            <span className="label-info">{user?.name}</span>
          </Typography>
          <Typography variant="body1" gutterBottom>
            <span className="label">Email:</span>{" "}
            <span className="label-info">{user?.email}</span>
          </Typography>
          {/* Other profile information here */}
          <Button
            variant="contained"
            color="primary"
            style={{ marginTop: "5px !important" }}
            onClick={() => {
              // Handle profile update
            }}
          >
            Update Profile
          </Button>
        </div>
      ) : (
        <div>
          <Typography variant="body1" gutterBottom>
            Please log in to view your profile.
          </Typography>
        </div>
      )}
    </Container>
  );
};

export default Profile;





pages/ProfileUpdatePage/ProfileUpdatePage.tsx
import React, { useState, useEffect } from "react";
import { useSelector, useDispatch } from "react-redux";
import { Button, TextField, Typography, Container } from "@mui/material";
import { AuthActionTypes, User } from "redux/types/authTypes";
import { useNavigate } from "react-router-dom";
import "./ProfileUpdatePage.css";
import { RootState } from "redux/combineReducer";
import api from "utils/api";
import Loader from "loader/Loader";

const UpdateProfile: React.FC = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const token = useSelector((state: RootState) => state.LoginAuthReducer.token);
  const [formData, setFormData] = useState<User | null>(null);
  const [initialFormData, setInitialFormData] = useState<User | null>(null);
  const [isDataChanged, setIsDataChanged] = useState<boolean>(false);

  useEffect(() => {
    const fetchUserProfile = async () => {
      try {
        if (!token) {
          throw new Error("Token not found");
        }
        const response = await api.get(
          `${process.env.REACT_APP_API}/api/getuser`,
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );

        if (response.data.success === true && response.status === 200) {
          const user = response.data.user;
          setFormData(user);
          setInitialFormData(user);
        }
        //  else {
        //   console.log("Error fetching user data.");
        // }
      } catch (error: any) {
        // console.log(error);
        if (error.response?.status === 401) {
          // console.log("Mitanshu Unauthorized ProfileUpdate");
          dispatch({ type: AuthActionTypes.LOGOUT });
          navigate("/login");
        }
      }
    };

    fetchUserProfile();
  }, [dispatch, navigate, token]);

  useEffect(() => {
    if (formData && initialFormData) {
      const isChanged =
        formData.firstname !== initialFormData.firstname ||
        formData.lastname !== initialFormData.lastname ||
        formData.email !== initialFormData.email ||
        formData.phone !== initialFormData.phone;
      setIsDataChanged(isChanged);
    }
  }, [formData, initialFormData]);

  const handleUpdate = async (event: React.FormEvent) => {
    event.preventDefault();
    try {
      if (!token) {
        throw new Error("Token not found");
      }
      if (formData) {
        await api.put(
          `${process.env.REACT_APP_API}/api/updateuser/${formData._id}`,
          formData,
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );
        navigate("/profile");
      }
      //  else {
      //   console.log("formData is null");
      // }
    } catch (error: any) {
      // console.log(error);
      if (error.response?.status === 401) {
        // console.log("Mitanshu Unauthorized ProfileUpdate state");
        dispatch({ type: AuthActionTypes.LOGOUT });
        navigate("/login");
      }
    }
  };

  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (formData) {
      setFormData({
        ...formData,
        [event.target.name]: event.target.value,
      });
      setIsDataChanged(true);
    }
  };

  return (
    <Container maxWidth="md">
      <Typography className="title">Update Profile</Typography>
      {formData ? (
        <form onSubmit={handleUpdate}>
          <TextField
            fullWidth
            margin="normal"
            label="First Name"
            name="firstname"
            value={formData.firstname}
            onChange={handleChange}
          />
          <TextField
            fullWidth
            margin="normal"
            label="Last Name"
            name="lastname"
            value={formData.lastname}
            onChange={handleChange}
          />
          <TextField
            fullWidth
            margin="normal"
            label="Email"
            name="email"
            value={formData.email}
            onChange={handleChange}
          />
          <TextField
            fullWidth
            margin="normal"
            label="Phone"
            name="phone"
            value={formData.phone}
            onChange={handleChange}
          />
          <Button
            variant="contained"
            color="error"
            type="button"
            sx={{ marginRight: "8px" }}
            // disabled={isDataChanged}
            onClick={() => navigate("/profile")}
          >
            Cancel
          </Button>
          <Button
            variant="contained"
            color="primary"
            type="submit"
            disabled={!isDataChanged}
          >
            Update Profile
          </Button>
        </form>
      ) : (
        <Loader />
      )}
    </Container>
  );
};

export default UpdateProfile;





loader/loader.tsx
import React from "react";
import CircularProgress from "@mui/material/CircularProgress";
import { Box } from "@mui/material";

const Loader = () => {
  return (
    <Box
      sx={{
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        // height: "100vh",
      }}
    >
      <CircularProgress />
    </Box>
  );
};

export default Loader;





context/authContext.tsx
import React, { createContext, useContext, useEffect, useState } from "react";
import {
  // Auth0Provider,
  useAuth0,
} from "@auth0/auth0-react";

interface AuthContextType {
  authed: boolean;
  loginHandle: () => void;
  logoutHandle: () => void;
}

const authContext = createContext<AuthContextType | null>(null);

export const AuthProvider = ({ children }: any) => {
  const [authed, setAuthed] = useState(false);
  const { isAuthenticated, loginWithRedirect, logout } = useAuth0();

  const loginHandle = () => {
    loginWithRedirect();
  };

  const logoutHandle = () => {
    // logout({ returnTo: window.location.origin });
    logout();
  };

  useEffect(() => {
    if (isAuthenticated) {
      setAuthed(true);
    } else {
      setAuthed(false);
    }
  }, [isAuthenticated]);

  return (
    <authContext.Provider value={{ authed, loginHandle, logoutHandle }}>
      {children}
    </authContext.Provider>
  );
};

export function useAuth() {
  return useContext(authContext);
}





components/Layout/Layout.tsx
import { Grid } from "@mui/material";
import React, { useState } from "react";
import "../Layout/Layout.css";
import { Outlet } from "react-router-dom";
import Sidebar from "../Sidebar/Sidebar";
import Navbar from "../Navbar/Navbar";

const Layout = (): JSX.Element => {
  const [isOpen, setIsClose] = useState<boolean>(true);

  const toggleSidebar = () => {
    setIsClose((toogle) => !toogle);
  };
  return (
    <div>
      <Grid className="layout">
        <Grid className={isOpen ? "layout-sidebar" : "layout-sidebar-sm"}>
          <Sidebar />
        </Grid>
        <Grid className="layout-navbar">
          <Navbar toogleSidebar={toggleSidebar} />
        </Grid>
        <Grid className="outlet">
          <Outlet />
        </Grid>
      </Grid>
    </div>
  );
};

export default Layout;





components/Navbar.tsx
import React, { useState, useEffect } from "react";
import { AppBar, Grid, Toolbar, Typography } from "@mui/material";
import MenuIcon from "@mui/icons-material/Menu";
import "../Navbar/Navbar.css";
import { useSelector } from "react-redux";
// import jwtDecode from "jwt-decode";
import { isAxiosError } from "axios";
import { AuthActionTypes } from "redux/types/authTypes";
import { useNavigate } from "react-router-dom";
import { useDispatch } from "react-redux";
import { RootState } from "redux/combineReducer";
import api from "utils/api";

interface NavbarProps {
  decodeToken?: {};
  firstname: string;
  lastname: string;
  role: string;
}
const Navbar = ({ toogleSidebar }: any): JSX.Element => {
  // const token = useSelector((state: any) => state.LoginAuthReducer.token);
  // const decodeToken: NavbarProps = token ? jwtDecode(token) : {};
  // const name = decodeToken.user?.firstname + " " + decodeToken.user?.lastname;
  // const role = decodeToken.user?.role;

  const [isOpen, setOpen] = useState<boolean>(false);
  const toogleSiderbar = () => {
    setOpen(!isOpen);
    toogleSidebar(isOpen);
  };

  const token = useSelector((state: RootState) => state.LoginAuthReducer.token);
  const [profile, setProfile] = useState<NavbarProps>();
  const dispatch = useDispatch();
  const navigate = useNavigate();

  useEffect(() => {
    const fetchUserProfile = async () => {
      try {
        if (!token) {
          throw new Error("Token Not Found");
        }
        const response = await api.get(
          `${process.env.REACT_APP_API}/api/getuser`,
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );
        if (response.data.success === true && response.status === 200) {
          setProfile(response.data.user);
        }
        // else {
        //   console.log("Error Fetching Data");
        // }
      } catch (error) {
        // console.log(error);
        if (isAxiosError(error)) {
          if (error.response?.status === 401) {
            // console.log("UnAuthorized User Profile Page");
            dispatch({ type: AuthActionTypes.LOGOUT });
            navigate("/login");
          }
        }
      }
    };
    fetchUserProfile();
  }, [dispatch, navigate, token]);

  return (
    <div>
      <Grid className="navbar">
        <AppBar className="appbar">
          <Toolbar className="toolbar-navbar">
            <MenuIcon className="menu-icon" onClick={toogleSiderbar} />
            <Grid className="navbar-name-content-center">
              <Typography className="navbar-title">Panel</Typography>
              {profile ? (
                <Typography className="navbar-name">
                  <span className="loggedInRole">
                    {profile?.role?.toUpperCase()}
                  </span>
                  <span className="loggedInName">
                    :{" "}
                    {profile?.firstname?.toUpperCase() +
                      " " +
                      profile?.lastname.toUpperCase()}
                  </span>
                </Typography>
              ) : null}
            </Grid>
          </Toolbar>
        </AppBar>
      </Grid>
    </div>
  );
};

export default Navbar;





components/Sidebar/Sidebar.tsx
import React from "react";
import {
  Divider,
  Grid,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Toolbar,
  Tooltip,
  Zoom,
} from "@mui/material";
import { Dashboard, Logout, Person } from "@mui/icons-material";
import "../Sidebar/Sidebar.css";
import { useNavigate } from "react-router-dom";
import { useDispatch } from "react-redux";
import { logout } from "redux/Action";
// import useAuth from "../../context/authContext";
import { NavLink } from "react-router-dom";

const Sidebar = (): JSX.Element => {
  const navigate = useNavigate();
  const dispatch = useDispatch();
  // const { logoutHandle }: any = useAuth();

  const handleLogout = async () => {
    await dispatch<any>(logout());
    // logoutHandle();
    navigate("/login");
  };
  return (
    <>
      <Grid className="sidebar">
        <Grid item lg={12} sm={6} xs={3}>
          <Toolbar />
          <Divider />

          <NavLink to={"/dashboard"} className={"link"}>
            <ListItem disablePadding className="sidebar-item">
              <Tooltip
                title={"Dashboard"}
                arrow
                TransitionComponent={Zoom}
                enterDelay={800}
                leaveDelay={200}
                placement="bottom"
              >
                <ListItemButton className="sidebar-listitem-btn">
                  <ListItemIcon className="sidebar-icon">
                    <Dashboard />
                  </ListItemIcon>
                  <ListItemText
                    primary="Dashboard"
                    sx={{ whiteSpace: "nowrap" }}
                  />
                </ListItemButton>
              </Tooltip>
            </ListItem>
          </NavLink>
          <Divider />

          <NavLink to={"/profile"} className={"link"}>
            <ListItem disablePadding className="sidebar-item">
              <Tooltip
                title={"Profile"}
                arrow
                TransitionComponent={Zoom}
                enterDelay={800}
                leaveDelay={200}
                placement="bottom"
              >
                <ListItemButton className="sidebar-listitem-btn">
                  <ListItemIcon className="sidebar-icon">
                    <Person />
                  </ListItemIcon>
                  <ListItemText
                    primary="Profile"
                    sx={{ whiteSpace: "nowrap" }}
                  />
                </ListItemButton>
              </Tooltip>
            </ListItem>
          </NavLink>
          <Divider />

          <ListItem disablePadding className="sidebar-item logout">
            <Tooltip
              title={"Logout"}
              arrow
              TransitionComponent={Zoom}
              enterDelay={800}
              leaveDelay={200}
              placement="bottom"
            >
              <ListItemButton
                className="sidebar-listitem-btn"
                onClick={handleLogout}
              >
                <ListItemIcon className="sidebar-icon">
                  <Logout />
                </ListItemIcon>
                <ListItemText primary="Logout" sx={{ whiteSpace: "nowrap" }} />
              </ListItemButton>
            </Tooltip>
          </ListItem>
          <Divider />
        </Grid>
      </Grid>
    </>
  );
};

export default Sidebar;










/*BACKEND*/
index.js
const express = require('express');
const app = express();
require('dotenv').config();
const cors = require("cors");
app.use(cors());
const mongoose = require('mongoose');
const User = require('./models/UserSchema');
const bodyParser = require('body-parser');
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
const colors = require("colors");
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const authMiddleware = require("./middleware/authMiddleware");

mongoose.connect(process.env.MONGO_URL).then(e => {
     console.log(`Connection established with Database`.bgGreen.white)
});
const PORT = process.env.PORT || 9936;
app.listen(PORT, () => {
     console.log(`connection successfull with ${PORT}`.bgWhite.white)
});
app.get('/', (req, res) => {
     res.send(`hello API`)
});

// Admin Register
app.post('/api/adminregister', async (req, res) => {
     try {
          let existingadmin = await User.findOne({ email: req.body.email });
          if (!!existingadmin) {
               return res.status(409).send({
                    success: false,
                    message: "Admin Already Registered!"
               })
          } else {
               const user = new User({
                    firstname: req.body.firstname,
                    lastname: req.body.lastname,
                    email: req.body.email,
                    phone: req.body.phone,
                    password: await bcrypt.hash(req.body.password, 10),
                    role: "admin",
               })
               await user.save();
               return res.status(200).send({
                    success: true,
                    message: "Successfully Registered",
                    user: user
               })
          }
     } catch (error) {
          console.log(error);
          res.status(404).send({
               success: false,
               message: "Something went wrong",
               error
          });
     }
});

// Login
app.post('/api/login', async (req, res) => {
     try {
          const user = await User.findOne({ email: req.body.email });
          if (!!user) {
               const hashedPassword = await bcrypt.compare(req.body.password, user.password);
               if (!!hashedPassword) {
                    const expiresIn = 500000;
                    const token = jwt.sign({ user }, process.env.JWT_SECRET, { expiresIn });
                    return res.status(200).send({
                         success: true,
                         message: "Login Successful",
                         result: { token, expiresIn }
                    })
               } else {
                    return res.status(401).send({
                         success: false,
                         message: "Invalid Password",
                    })
               }
          } else {
               return res.status(400).send({
                    success: false,
                    message: "User Not Found",
               })
          }
     } catch (error) {
          console.log(error);
          res.status(404).send({
               success: false,
               message: "Something went wrong",
               error
          });
     }
});

// Logout
app.post('/api/logout', (req, res) => {
     res.json({ success: true, message: 'Logout Successful' });
});

// Protected Route 
const protectedRoute = express.Router();
app.use(authMiddleware);

// Get User
protectedRoute.get('/api/getuser', async (req, res) => {
     try {
          // Get the user ID from req.user
          const userId = req.user._id;
          // Find the user by ID
          const user = await User.findById(userId);
          if (!user) {
               return res.status(404).send({ success: false, message: 'User not found' });
          }
          // Return the user information
          return res.status(200).send({
               success: true,
               message: 'User information retrieved successfully',
               user: user,
          });
     } catch (error) {
          console.error(error);
          return res.status(500).send({
               success: false,
               message: 'Something went wrong',
               error: error.message,
          });
     }
});

// Update User
protectedRoute.put('/api/updateuser/:id', async (req, res) => {
     try {
          // Get the user ID from req.user
          const userId = req.params.id;
          // Find the user by ID
          const user = await User.findById(userId);
          if (!user) {
               return res.status(404).send({ success: false, message: 'User not found' });
          }
          // Update user information based on request body
          user.firstname = req.body.firstname || user.firstname;
          user.lastname = req.body.lastname || user.lastname;
          user.email = req.body.email || user.email;
          user.phone = req.body.phone || user.phone;
          // Save the updated user to the database
          await user.save();

          return res.status(200).send({
               success: true,
               message: 'User updated successfully',
               user: user,
          });
     } catch (error) {
          console.error(error);
          return res.status(500).send({
               success: false,
               message: 'Something went wrong',
               error: error.message,
          });
     }
});
app.use(protectedRoute);





models/UserSchema.js
const mongoose = require('mongoose')
const User = new mongoose.Schema({
     firstname: { type: String, required: true },
     lastname: { type: String, required: true },
     phone: { type: Number, required: true },
     email: { type: String, required: true, unique: true },
     password: { type: String, required: true },
     role: { type: String }
}, { timestamps: true })
const model = new mongoose.model("Panel-Project", User)
module.exports = model





middleware/authMiddleware.js
const jwt = require("jsonwebtoken");
const authMiddleware = (req, res, next) => {
     const token = req.headers.authorization;
     if (!token) {
          return res.status(401).send({ success: false, message: "Authorization Headers Missing" });
     }
     try {
          const tokenWithoutBearer = token.replace('Bearer ', '');
          const decoded = jwt.verify(tokenWithoutBearer, process.env.JWT_SECRET);
          req.user = decoded.user;
          next();
     } catch (error) {
          if (error.name === 'TokenExpiredError') {
               return res.status(401).send({ success: false, message: 'Token has Expired' });
          }
          return res.status(401).send({ success: false, message: "Invalid Token" });
     }
};
module.exports = authMiddleware;